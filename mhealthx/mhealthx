#!/usr/bin/env python
"""
This pipeline runs feature extraction on mhealth data stored on Synapse.org.

This command results in a one-row csv table for each recordId.
This recordId corresponds to a source row of mhealth data --
a given participant, for a given activity, at a given time.
Follow the "mhealthx" command with the "mhealthy" command.

Example to prepare the first three rows of mhealth data from Synapse:

    mhealthx --voice syn4590865 --walk syn4590866 --tap syn4590864 \
             -d /software --rows 3 --setup

Example to extract features from the above three rows (remove "--setup"):

    mhealthx --voice syn4590865 --walk syn4590866 --tap syn4590864 \
             -d /software --rows 3

Note:
- First-time use on a given machine: include -u and -p for Synapse login.
- Replace -d argument with path to installed feature extraction software.

For help in using mhealthx ::

    - README file
    - Help on the command line::

        $ mhealthx --help

This file uses Nipype (http://www.nipy.org/nipype/) to create a workflow
environment that enables mhealthx to run in a flexible, modular manner
while storing provenance information. Authors are listed per file.

Authors:
    - Arno Klein, 2015-2016  (arno@sagebase.org)  http://binarybottle.com

Copyright 2016,  Sage Bionetworks (http://sagebase.org), Apache v2.0 License

"""

import os
import sys
import argparse
from nipype import config, logging
from nipype.interfaces.io import DataSink
from nipype.interfaces.utility import Function as Fn
from nipype.pipeline.engine import Workflow, Node
from mhealthx.extract import run_openSMILE, run_pyGait, run_signal_features, \
    run_tap_features, run_quality, run_sdf_features
from mhealthx.extractors.pyGait import project_walk_direction_attitude
from mhealthx.xio import extract_synapse_rows, write_wav, \
    get_convert_audio, get_accel, get_tap
from mhealthx.utilities import create_directory

# ============================================================================
#
# Command-line arguments
#
# ============================================================================
parser = argparse.ArgumentParser(description="""
                    Extract features from mHealth data
                    stored on Sage Bionetwork's Synapse.org.
                    Example: mhealthx --voice syn4590865 -d /software
                    (-d: path to installed software dependencies; -u, -p:
                    Synapse login for first use on a given machine)
""",
                                 formatter_class = lambda prog:
                                 argparse.HelpFormatter(prog,
                                                        max_help_position=40))
parser.add_argument("-v", "--version", help="version number",
                    action='version', version='%(prog)s 0.1')
parser.add_argument("-n", "--numproc",
                    help='number of processors (default: 1)',
                    type=int, default=1, metavar='INT')
parser.add_argument("-r", "--rows",
                    help='download this number of rows of the Synapse tables',
                    type=int, metavar='INT', default=sys.maxint)
parser.add_argument('--records', dest='records',
                    help='create tables from these recordIds', metavar='STR')
parser.add_argument('--reports', dest='reports', action='store_true',
                    help='generate nipype reports')
parser.add_argument("--graph",
                    help='plot workflow graph: "hier", "flat", "exec"',
                    choices=['hier', 'flat', 'exec'], metavar='STR')
parser.add_argument("--plugin", dest="plugin",
                    default='Linear',
                    help="optional plugin: --plugin PBS")
parser.add_argument("--plugin_args", dest="plugin_args",
                    help="optional plugin arguments:"
                         " --plugin_args \"dict(qsub_args='-q many')\"")
setup_group = parser.add_argument_group('setup')
setup_group.add_argument("-s", "--setup",
                         help="setup: download mhealth data",
                         action='store_true')
setup_group.add_argument("-d", "--dependencies",
                         help="path to software dependencies",
                         metavar='STR')
setup_group.add_argument("-u", "--username",
                         help="Synapse username", metavar='STR')
setup_group.add_argument("-p", "--password",
                         help="Synapse password", metavar='STR')
activities_group = parser.add_argument_group('activities')
activities_group.add_argument("--voice",
                              help="Synapse table ID for voice data",
                              metavar='STR')
activities_group.add_argument("--walk",
                              help="Synapse table ID for walk/balance data",
                              metavar='STR')
activities_group.add_argument("--tap",
                              help="Synapse table ID for tap touchscreen "
                                   "data",
                              metavar='STR')
outputs_group = parser.add_argument_group('outputs')
outputs_group.add_argument("-o", "--outputs",
                           help='output folder (if not $HOME/mhealthx_output)',
                           default=os.path.join(os.environ['HOME'],
                                                'mhealthx_output'),
                           metavar='STR')
outputs_group.add_argument("-c", "--cache",
                           help="cache folder (if not "
                                "$HOME/mhealthx_output/mhealthx_cache)",
                           default=os.path.join(os.environ['HOME'],
                                                'mhealthx_output',
                                                'mhealthx_cache'),
                           metavar='STR')
outputs_group.add_argument("-t", "--temp",
                           help='temp folder (if not same as --cache)',
                           metavar='STR')
args = parser.parse_args()
username = args.username
password = args.password
dependencies = args.dependencies
setup_rows = args.setup
records = args.records
if args.temp:
    temporary_path = args.temp
else:
    temporary_path = args.cache
synID_voice = args.voice
synID_walk = args.walk
synID_tap = args.tap

# ============================================================================
#
# Third-party software setup
#
# ============================================================================
# openSMILE information:
if dependencies:
    # find openSmile directory in order to track what version we're using
    # smile_version = 'openSMILE-2.1.0'
    smile_version = 'openSMILE-2.2rc1'
    smile_dir = os.path.join(dependencies, smile_version)
    if not os.path.isdir(smile_dir):
        raise IOError("Couldn't find openSmile at "+smile_dir)
    else:
        print "found ", smile_version

    # smile_config = 'IS13_ComParE.conf'
    smile_config = os.path.join('gemaps', 'GeMAPSv01a.conf')
    smile_string = '_{0}_{1}'.format(smile_version, 'GeMAPSv01a')

    smile_config_file = os.path.join(dependencies, smile_version,
                                        'config', smile_config)
else:
    raise Warning("dependencies not set -- cannot run openSMILE!")

# ============================================================================
#
# Login once to Synapse and cache credentials
#
# ============================================================================
import synapseclient
syn = synapseclient.Synapse()
syn.login(username, password, rememberMe=True)

# ============================================================================
#
# Initialize main workflow and create output directories
#
# ============================================================================
main_workflow_name = 'mhealthx'
Flow = Workflow(name=main_workflow_name)
Flow.base_dir = args.cache
Sink = Node(DataSink(), name='Results')
Sink.inputs.base_directory = args.outputs
if not os.path.isdir(args.outputs):
    print("Create missing output directory: {0}".format(args.outputs))
    os.makedirs(args.outputs)
if not os.path.isdir(args.cache):
    print("Create missing cache directory: {0}".format(args.cache))
    os.makedirs(args.cache)
feature_table_path = os.path.join(args.outputs, 'feature_tables')
if not os.path.isdir(feature_table_path):
    os.makedirs(feature_table_path)
row_path = os.path.join(args.cache, main_workflow_name)
path_voice = os.path.join(row_path, 'row_files_voice')
path_walk = os.path.join(row_path, 'row_files_walk')
path_tap = os.path.join(row_path, 'row_files_tap')

# ============================================================================
#
# Voice: phonation (microphone)
#
# ============================================================================
if not os.path.isdir(path_voice):
    os.makedirs(path_voice)

# ------------------------------------------------------------------------
# Retrieve information about all voice files in Synapse table:
# ------------------------------------------------------------------------
GetPhonationRows = Node(name='retrieve_voice_rows',
                        interface=Fn(function=extract_synapse_rows,
                                     input_names=['synapse_table',
                                                  'save_path',
                                                  'limit',
                                                  'username',
                                                  'password'],
                                     output_names=['row_data',
                                                   'row_files']))
GetPhonationRows.inputs.synapse_table = synID_voice
GetPhonationRows.inputs.save_path = path_voice
if args.rows:
    GetPhonationRows.inputs.limit = args.rows
else:
    GetPhonationRows.inputs.limit = None
GetPhonationRows.inputs.username = ''
GetPhonationRows.inputs.password = ''

if synID_voice and setup_rows:
    Flow.add_nodes([GetPhonationRows])
elif synID_voice and not setup_rows:
    if records:
        fid = open(records)
        lines = fid.readlines()
        rows_voice = []
        for recordId in lines:
            [rows_voice.append(os.path.join(path_voice, f))
             for f in os.listdir(path_voice) if recordId.strip() in f]
    else:
        rows_voice = [os.path.join(path_voice, f)
                      for i, f in enumerate(sorted(os.listdir(path_voice)))
                      if i < args.rows
                      and os.path.isfile(os.path.join(path_voice, f))]

    # ------------------------------------------------------------------------
    # Voice data:
    # 1. Retrieve each row + audio file from a Synapse table.
    # 2. Convert voice file to .wav format.
    # ------------------------------------------------------------------------
    getPhonation = Node(name='voice_data',
                        interface=Fn(function=get_convert_audio,
                                     input_names=['synapse_table',
                                                  'row',
                                                  'column_name',
                                                  'convert_file_append',
                                                  'convert_command',
                                                  'convert_input_args',
                                                  'convert_output_args',
                                                  'out_path',
                                                  'username',
                                                  'password'],
                                     output_names=['row',
                                                   'new_file']))
    getPhonation.inputs.synapse_table = synID_voice
    getPhonation.iterables = ("row", rows_voice)
    getPhonation.inputs.column_name = 'audio_audio.m4a'
    getPhonation.inputs.convert_file_append = '.wav'
    getPhonation.inputs.convert_command = 'ffmpeg'
    getPhonation.inputs.convert_input_args = '-y -i'
    getPhonation.inputs.convert_output_args = '-ac 2'
    getPhonation.inputs.out_path = None
    getPhonation.inputs.username = ''
    getPhonation.inputs.password = ''

    # ------------------------------------------------------------------------
    # Repeat for voice countdown data:
    # ------------------------------------------------------------------------
    getPhonation0 = getPhonation.clone('voice_count_data')
    getPhonation0.inputs.column_name = 'audio_countdown.m4a'

    # ------------------------------------------------------------------------
    # openSMILE on voice data:
    # 1. Run openSMILE's SMILExtract audio feature extraction command.
    # 2. Construct a feature row from the original and openSMILE rows.
    # 3. Write the feature row to a table or append to a feature table.
    # ------------------------------------------------------------------------
    SMILEvoice = Node(name='openSMILE_voice',
                      interface=Fn(function=run_openSMILE,
                                   input_names=['audio_file',
                                                'command',
                                                'flag1',
                                                'flags',
                                                'flagn',
                                                'args',
                                                'closing',
                                                'row',
                                                'table_stem',
                                                'save_rows'],
                                   output_names=['feature_row',
                                                 'feature_table']))
    Flow.connect(getPhonation, 'new_file', SMILEvoice, 'audio_file')
    Flow.connect(getPhonation, 'row', SMILEvoice, 'row')
    SMILEvoice.inputs.command = 'SMILExtract'
    SMILEvoice.inputs.flag1 = '-I'
    SMILEvoice.inputs.flags = '-C'
    SMILEvoice.inputs.flagn = '-csvoutput'
    SMILEvoice.inputs.args = smile_config_file
    SMILEvoice.inputs.closing = '-nologfile 1'
    SMILEvoice.inputs.table_stem = \
        os.path.join(feature_table_path, 'voice{0}'.format(smile_string))
    SMILEvoice.inputs.save_rows = True

    create_directory(SMILEvoice.inputs.table_stem)

    # ------------------------------------------------------------------------
    # Repeat for voice countdown data:
    # ------------------------------------------------------------------------
    SMILEvoice0 = SMILEvoice.clone('openSMILE_voice_count')
    Flow.connect(getPhonation0, 'new_file', SMILEvoice0, 'audio_file')
    Flow.connect(getPhonation0, 'row', SMILEvoice0, 'row')
    SMILEvoice0.inputs.table_stem = os.path.join(feature_table_path,
        'voice_count{0}'.format(smile_string))

    create_directory(SMILEvoice0.inputs.table_stem)


# ============================================================================
#
# Walk and balance (accelerometer)
#
# ============================================================================
if synID_walk and setup_rows:
    if not os.path.isdir(path_walk):
        os.makedirs(path_walk)

    # ------------------------------------------------------------------------
    # Retrieve information about all balance files in Synapse table:
    # ------------------------------------------------------------------------
    GetBalanceRows = GetPhonationRows.clone('retrieve_balance_rows')
    GetBalanceRows.inputs.synapse_table = synID_walk
    GetBalanceRows.inputs.save_path = path_walk
    Flow.add_nodes([GetBalanceRows])

elif synID_walk and not setup_rows:
    if records:
        fid = open(records)
        lines = fid.readlines()
        rows_walk = []
        for recordId in lines:
            [rows_walk.append(os.path.join(path_walk, f))
             for f in os.listdir(path_walk) if recordId.strip() in f]
    else:
        rows_walk = [os.path.join(path_walk, f)
                     for i, f in enumerate(sorted(os.listdir(path_walk)))
                     if i < args.rows
                     and os.path.isfile(os.path.join(path_walk, f))]

    # ------------------------------------------------------------------------
    # Balance data: retrieve each row + json file from Synapse table:
    # ------------------------------------------------------------------------
    getBalance = Node(name='balance_data',
                      interface=Fn(function=get_accel,
                                   input_names=['synapse_table',
                                                'row',
                                                'column_name',
                                                'start',
                                                'device_motion',
                                                'out_path',
                                                'username',
                                                'password'],
                                   output_names=['t',
                                                 'ax',
                                                 'ay',
                                                 'az',
                                                 'gx',
                                                 'gy',
                                                 'gz',
                                                 'rx',
                                                 'ry',
                                                 'rz',
                                                 'uw',
                                                 'ux',
                                                 'uy',
                                                 'uz',
                                                 'sample_rate',
                                                 'duration',
                                                 'row',
                                                 'file_path']))
    getBalance.inputs.synapse_table = synID_walk
    getBalance.iterables = ("row", rows_walk)
    #getBalance.inputs.column_name = 'accel_walking_rest.json.items'
    getBalance.inputs.column_name = 'deviceMotion_walking_rest.json.items'
    getBalance.inputs.start = 150
    #getBalance.inputs.device_motion = False
    getBalance.inputs.device_motion = True
    getBalance.inputs.out_path = None
    getBalance.inputs.username = ''
    getBalance.inputs.password = ''

    # ------------------------------------------------------------------------
    # Repeat for walk data (deviceMotion):
    # ------------------------------------------------------------------------
    getWalking = Node(name='walk_data',
                      interface=Fn(function=get_accel,
                                   input_names=['synapse_table',
                                                'row',
                                                'column_name',
                                                'start',
                                                'device_motion',
                                                'out_path',
                                                'username',
                                                'password'],
                                   output_names=['t',
                                                 'ax',
                                                 'ay',
                                                 'az',
                                                 'gx',
                                                 'gy',
                                                 'gz',
                                                 'rx',
                                                 'ry',
                                                 'rz',
                                                 'uw',
                                                 'ux',
                                                 'uy',
                                                 'uz',
                                                 'sample_rate',
                                                 'duration',
                                                 'row',
                                                 'file_path']))
    getWalking.inputs.synapse_table = synID_walk
    getWalking.iterables = ("row", rows_walk)
    getWalking.inputs.column_name = 'deviceMotion_walking_outbound.json.items'
    getWalking.inputs.start = 150
    getWalking.inputs.device_motion = True
    getWalking.inputs.out_path = None
    getWalking.inputs.username = ''
    getWalking.inputs.password = ''

    # ------------------------------------------------------------------------
    # Compute QC score based on gravity acceleration only:
    # ------------------------------------------------------------------------
    accelQC = Node(name='walk_QC',
                   interface=Fn(function=run_quality,
                                input_names=['gx',
                                             'gy',
                                             'gz',
                                             'row',
                                             'file_path',
                                             'table_stem',
                                             'save_rows'],
                                output_names=['min_mse',
                                              'vertical']))
    Flow.connect(getWalking, 'gx', accelQC, 'gx')
    Flow.connect(getWalking, 'gy', accelQC, 'gy')
    Flow.connect(getWalking, 'gz', accelQC, 'gz')
    Flow.connect(getWalking, 'row', accelQC, 'row')
    Flow.connect(getWalking, 'file_path', accelQC, 'file_path')
    accelQC.inputs.table_stem = os.path.join(feature_table_path, 'walk_qc')
    accelQC.inputs.save_rows = True

    create_directory(accelQC.inputs.table_stem)

    # ------------------------------------------------------------------------
    # Project walk accelerometer axes on walk direction (attitude rotation):
    # ------------------------------------------------------------------------
    projectAccel = Node(name='project_walk_direction_attitude',
                        interface=Fn(function=project_walk_direction_attitude,
                                     input_names=['ax',
                                                  'ay',
                                                  'az',
                                                  'uw',
                                                  'ux',
                                                  'uy',
                                                  'uz'],
                                     output_names=['px',
                                                   'py',
                                                   'pz']))
    Flow.connect(getWalking, 'ax', projectAccel, 'ax')
    Flow.connect(getWalking, 'ay', projectAccel, 'ay')
    Flow.connect(getWalking, 'az', projectAccel, 'az')
    Flow.connect(getWalking, 'uw', projectAccel, 'uw')
    Flow.connect(getWalking, 'ux', projectAccel, 'ux')
    Flow.connect(getWalking, 'uy', projectAccel, 'uy')
    Flow.connect(getWalking, 'uz', projectAccel, 'uz')

    # ------------------------------------------------------------------------
    # Project walk accelerometer axes on walk direction (pre-heel strike):
    # ------------------------------------------------------------------------
    # projectAccelHeel = Node(name='project_walk_direction_preheel',
    #                     interface=Fn(function=project_walk_direction_preheel,
    #                                  input_names=['ax',
    #                                               'ay',
    #                                               'az',
    #                                               't',
    #                                               'sample_rate',
    #                                               'stride_fraction',
    #                                               'threshold',
    #                                               'order',
    #                                               'cutoff'],
    #                                  output_names=['px',
    #                                                'py',
    #                                                'pz']))
    # Flow.connect(getWalking, 'ax', projectAccelHeel, 'ax')
    # Flow.connect(getWalking, 'ay', projectAccelHeel, 'ay')
    # Flow.connect(getWalking, 'az', projectAccelHeel, 'az')
    # Flow.connect(getWalking, 't', projectAccelHeel, 't')
    # Flow.connect(getWalking, 'sample_rate', projectAccelHeel, 'sample_rate')
    # projectAccelHeel.inputs.stride_fraction = 1.0/8.0
    # projectAccelHeel.inputs.threshold = 0.5
    # projectAccelHeel.inputs.order = 4
    # projectAccelHeel.inputs.cutoff = 10

    # ------------------------------------------------------------------------
    # Estimate distance from walk accelerometer data:
    # ------------------------------------------------------------------------
    # deadReckon = Node(name='dead_reckon',
    #                   interface=Fn(function=dead_reckon,
    #                                input_names=['ax',
    #                                             'ay',
    #                                             'az',
    #                                             't'],
    #                                output_names=['x',
    #                                              'y',
    #                                              'z',
    #                                              'distance']))
    # Flow.connect(getWalking, 'ax', deadReckon, 'ax')
    # Flow.connect(getWalking, 'ay', deadReckon, 'ay')
    # Flow.connect(getWalking, 'az', deadReckon, 'az')
    # Flow.connect(getWalking, 't', deadReckon, 't')

    # ------------------------------------------------------------------------
    # pyGait on walk data (forward walk direction):
    # ------------------------------------------------------------------------
    pyGaitWalk = Node(name='pyGait_walk',
                      interface=Fn(function=run_pyGait,
                                   input_names=['data',
                                                't',
                                                'sample_rate',
                                                'duration',
                                                'threshold',
                                                'order',
                                                'cutoff',
                                                'distance',
                                                'row',
                                                'file_path',
                                                'table_stem',
                                                'save_rows'],
                                   output_names=['feature_row',
                                                 'feature_table']))
    #Flow.connect(projectAccelHeel, 'py', pyGaitWalk, 'data')
    Flow.connect(projectAccel, 'py', pyGaitWalk, 'data')
    Flow.connect(getWalking, 't', pyGaitWalk, 't')
    Flow.connect(getWalking, 'sample_rate', pyGaitWalk, 'sample_rate')
    Flow.connect(getWalking, 'duration', pyGaitWalk, 'duration')
    pyGaitWalk.inputs.threshold = 0.4
    pyGaitWalk.inputs.order = 4
    pyGaitWalk.inputs.cutoff = 10
    pyGaitWalk.inputs.distance = None
    #Flow.connect(deadReckon, 'distance', pyGaitWalk, 'distance')
    Flow.connect(getWalking, 'row', pyGaitWalk, 'row')
    Flow.connect(getWalking, 'file_path', pyGaitWalk, 'file_path')
    pyGaitWalk.inputs.table_stem = os.path.join(feature_table_path,
                                                'walk_pyGait')
    pyGaitWalk.inputs.save_rows = True

    create_directory(pyGaitWalk.inputs.table_stem)


    # ------------------------------------------------------------------------
    # signal_features() on walk data (each axis):
    # ------------------------------------------------------------------------
    signalsWalkX = Node(name='signals_walk_x',
                        interface=Fn(function=run_signal_features,
                                     input_names=['data',
                                                  'row',
                                                  'file_path',
                                                  'table_stem',
                                                  'save_rows'],
                                     output_names=['feature_row',
                                                   'feature_table']))
    signalsWalkX.inputs.save_rows = True
    signalsWalkY = signalsWalkX.clone('signals_walk_y')
    signalsWalkZ = signalsWalkX.clone('signals_walk_z')
    Flow.connect(projectAccel, 'px', signalsWalkX, 'data')
    Flow.connect(projectAccel, 'py', signalsWalkY, 'data')
    Flow.connect(projectAccel, 'pz', signalsWalkZ, 'data')
    Flow.connect(getWalking, 'row', signalsWalkX, 'row')
    Flow.connect(getWalking, 'row', signalsWalkY, 'row')
    Flow.connect(getWalking, 'row', signalsWalkZ, 'row')
    Flow.connect(getWalking, 'file_path', signalsWalkX, 'file_path')
    Flow.connect(getWalking, 'file_path', signalsWalkY, 'file_path')
    Flow.connect(getWalking, 'file_path', signalsWalkZ, 'file_path')
    signalsWalkX.inputs.table_stem = os.path.join(feature_table_path,
                                                  'walk_x_signals')
    signalsWalkY.inputs.table_stem = os.path.join(feature_table_path,
                                                  'walk_y_signals')
    signalsWalkZ.inputs.table_stem = os.path.join(feature_table_path,
                                                  'walk_z_signals')

    create_directory(signalsWalkX.inputs.table_stem)
    create_directory(signalsWalkY.inputs.table_stem)
    create_directory(signalsWalkZ.inputs.table_stem)

    # ------------------------------------------------------------------------
    # signal_features() on balance data (each axis):
    # ------------------------------------------------------------------------
    signalsBalanceX = Node(name='signals_balance_x',
                           interface=Fn(function=run_signal_features,
                                        input_names=['data',
                                                     'row',
                                                     'file_path',
                                                     'table_stem',
                                                     'save_rows'],
                                        output_names=['feature_row',
                                                      'feature_table']))
    signalsBalanceX.inputs.save_rows = True
    signalsBalanceY = signalsBalanceX.clone('signals_balance_y')
    signalsBalanceZ = signalsBalanceX.clone('signals_balance_z')
    Flow.connect(projectAccel, 'px', signalsBalanceX, 'data')
    Flow.connect(projectAccel, 'py', signalsBalanceY, 'data')
    Flow.connect(projectAccel, 'pz', signalsBalanceZ, 'data')
    Flow.connect(getBalance, 'row', signalsBalanceX, 'row')
    Flow.connect(getBalance, 'row', signalsBalanceY, 'row')
    Flow.connect(getBalance, 'row', signalsBalanceZ, 'row')
    Flow.connect(getBalance, 'file_path', signalsBalanceX, 'file_path')
    Flow.connect(getBalance, 'file_path', signalsBalanceY, 'file_path')
    Flow.connect(getBalance, 'file_path', signalsBalanceZ, 'file_path')
    signalsBalanceX.inputs.table_stem = os.path.join(feature_table_path,
                                                     'balance_x_signals')
    signalsBalanceY.inputs.table_stem = os.path.join(feature_table_path,
                                                     'balance_y_signals')
    signalsBalanceZ.inputs.table_stem = os.path.join(feature_table_path,
                                                     'balance_z_signals')

    create_directory(signalsBalanceX.inputs.table_stem)
    create_directory(signalsBalanceY.inputs.table_stem)
    create_directory(signalsBalanceZ.inputs.table_stem)

    # ------------------------------------------------------------------------
    # Symbolic Dynamic Filtering on walk data (each axis):
    # ------------------------------------------------------------------------
    sdfWalkX = Node(name='sdf_walk_x',
                    interface=Fn(function=run_sdf_features,
                                 input_names=['data',
                                              'number_of_symbols',
                                              'row',
                                              'file_path',
                                              'table_stem',
                                              'save_rows'],
                                 output_names=['feature_row',
                                               'feature_table']))
    sdfWalkX.inputs.number_of_symbols = 4
    sdfWalkX.inputs.save_rows = True
    sdfWalkY = sdfWalkX.clone('sdf_walk_y')
    sdfWalkZ = sdfWalkX.clone('sdf_walk_z')
    Flow.connect(projectAccel, 'px', sdfWalkX, 'data')
    Flow.connect(projectAccel, 'py', sdfWalkY, 'data')
    Flow.connect(projectAccel, 'pz', sdfWalkZ, 'data')
    Flow.connect(getWalking, 'row', sdfWalkX, 'row')
    Flow.connect(getWalking, 'row', sdfWalkY, 'row')
    Flow.connect(getWalking, 'row', sdfWalkZ, 'row')
    Flow.connect(getWalking, 'file_path', sdfWalkX, 'file_path')
    Flow.connect(getWalking, 'file_path', sdfWalkY, 'file_path')
    Flow.connect(getWalking, 'file_path', sdfWalkZ, 'file_path')
    sdfWalkX.inputs.table_stem = os.path.join(feature_table_path,
                                              'walk_x_sdf')
    sdfWalkY.inputs.table_stem = os.path.join(feature_table_path,
                                              'walk_y_sdf')
    sdfWalkZ.inputs.table_stem = os.path.join(feature_table_path,
                                              'walk_z_sdf')

    create_directory(sdfWalkX.inputs.table_stem)
    create_directory(sdfWalkY.inputs.table_stem)
    create_directory(sdfWalkZ.inputs.table_stem)

    # ------------------------------------------------------------------------
    # Repeat for balance data (each axis):
    # ------------------------------------------------------------------------
    sdfBalanceX = Node(name='sdf_balance_x',
                       interface=Fn(function=run_sdf_features,
                                    input_names=['data',
                                                 'number_of_symbols',
                                                 'row',
                                                 'file_path',
                                                 'table_stem',
                                                 'save_rows'],
                                    output_names=['feature_row',
                                                  'feature_table']))
    sdfBalanceX.inputs.number_of_symbols = 4
    sdfBalanceX.inputs.save_rows = True
    sdfBalanceY = sdfBalanceX.clone('sdf_balance_y')
    sdfBalanceZ = sdfBalanceX.clone('sdf_balance_z')
    Flow.connect(projectAccel, 'px', sdfBalanceX, 'data')
    Flow.connect(projectAccel, 'py', sdfBalanceY, 'data')
    Flow.connect(projectAccel, 'pz', sdfBalanceZ, 'data')
    Flow.connect(getBalance, 'row', sdfBalanceX, 'row')
    Flow.connect(getBalance, 'row', sdfBalanceY, 'row')
    Flow.connect(getBalance, 'row', sdfBalanceZ, 'row')
    Flow.connect(getBalance, 'file_path', sdfBalanceX, 'file_path')
    Flow.connect(getBalance, 'file_path', sdfBalanceY, 'file_path')
    Flow.connect(getBalance, 'file_path', sdfBalanceZ, 'file_path')
    sdfBalanceX.inputs.table_stem = os.path.join(feature_table_path,
                                                 'balance_x_sdf')
    sdfBalanceY.inputs.table_stem = os.path.join(feature_table_path,
                                                 'balance_y_sdf')
    sdfBalanceZ.inputs.table_stem = os.path.join(feature_table_path,
                                                 'balance_z_sdf')

    create_directory(sdfBalanceX.inputs.table_stem)
    create_directory(sdfBalanceY.inputs.table_stem)
    create_directory(sdfBalanceZ.inputs.table_stem)

    # ------------------------------------------------------------------------
    # Convert balance data from json to wav format for each axis:
    # ------------------------------------------------------------------------
    # WAVbalanceX = Node(name='convert_balance_x_to_wav',
    #                    interface=Fn(function=write_wav,
    #                                 input_names=['data',
    #                                              'file_stem',
    #                                              'file_append',
    #                                              'sample_rate',
    #                                              'amplitude'],
    #                                 output_names=['wav_file']))
    # WAVbalanceX.inputs.file_append = '.wav'
    # WAVbalanceX.inputs.amplitude = 32700
    # WAVbalanceY = WAVbalanceX.clone('convert_balance_y_to_wav')
    # WAVbalanceZ = WAVbalanceX.clone('convert_balance_z_to_wav')
    # Flow.connect(getBalance, 'ax', WAVbalanceX, 'data')
    # Flow.connect(getBalance, 'ay', WAVbalanceY, 'data')
    # Flow.connect(getBalance, 'az', WAVbalanceZ, 'data')
    # Flow.connect(getBalance, 'file_path', WAVbalanceX, 'file_stem')
    # Flow.connect(getBalance, 'file_path', WAVbalanceY, 'file_stem')
    # Flow.connect(getBalance, 'file_path', WAVbalanceZ, 'file_stem')
    # Flow.connect(getBalance, 'sample_rate', WAVbalanceX, 'sample_rate')
    # Flow.connect(getBalance, 'sample_rate', WAVbalanceY, 'sample_rate')
    # Flow.connect(getBalance, 'sample_rate', WAVbalanceZ, 'sample_rate')

    # ------------------------------------------------------------------------
    # Repeat for walk data:
    # ------------------------------------------------------------------------
    # WAVwalkX = Node(name='convert_walk_x_to_wav',
    #                 interface=Fn(function=write_wav,
    #                              input_names=['data',
    #                                           'file_stem',
    #                                           'file_append',
    #                                           'sample_rate',
    #                                           'amplitude'],
    #                              output_names=['wav_file']))
    # WAVwalkX.inputs.file_append = '.wav'
    # WAVwalkX.inputs.amplitude = 32700
    # WAVwalkY = WAVwalkX.clone('convert_walk_y_to_wav')
    # WAVwalkZ = WAVwalkX.clone('convert_walk_z_to_wav')
    # Flow.connect(projectAccel, 'px', WAVwalkX, 'data')
    # Flow.connect(projectAccel, 'py', WAVwalkY, 'data')
    # Flow.connect(projectAccel, 'pz', WAVwalkZ, 'data')
    # Flow.connect(getBalance, 'file_path', WAVwalkX, 'file_stem')
    # Flow.connect(getBalance, 'file_path', WAVwalkY, 'file_stem')
    # Flow.connect(getBalance, 'file_path', WAVwalkZ, 'file_stem')
    # Flow.connect(getBalance, 'sample_rate', WAVwalkX, 'sample_rate')
    # Flow.connect(getBalance, 'sample_rate', WAVwalkY, 'sample_rate')
    # Flow.connect(getBalance, 'sample_rate', WAVwalkZ, 'sample_rate')

    # ------------------------------------------------------------------------
    # openSMILE on each axis of balance data:
    # 1. Run openSMILE's SMILExtract audio feature extraction command.
    # 2. Construct a feature row from the original and openSMILE rows.
    # 3. Write the feature row to a table or append to a feature table.
    # ------------------------------------------------------------------------
    # SMILEbalanceX = Node(name='openSMILE_balance_x',
    #                      interface=Fn(function=run_openSMILE,
    #                                   input_names=['audio_file',
    #                                                'command',
    #                                                'flag1',
    #                                                'flags',
    #                                                'flagn',
    #                                                'args',
    #                                                'closing',
    #                                                'row',
    #                                                'table_stem',
    #                                                'save_rows'],
    #                                   output_names=['feature_row',
    #                                                 'feature_table']))
    # SMILEbalanceX.inputs.command = 'SMILExtract'
    # SMILEbalanceX.inputs.flag1 = '-I'
    # SMILEbalanceX.inputs.flags = '-C'
    # SMILEbalanceX.inputs.flagn = '-csvoutput'
    # SMILEbalanceX.inputs.args = smile_config_file
    # SMILEbalanceX.inputs.closing = '-nologfile 1'
    # SMILEbalanceX.inputs.save_rows = True

    # SMILEbalanceY = SMILEbalanceX.clone('openSMILE_balance_y')
    # SMILEbalanceZ = SMILEbalanceX.clone('openSMILE_balance_z')
    # Flow.connect(WAVbalanceX, 'wav_file', SMILEbalanceX, 'audio_file')
    # Flow.connect(WAVbalanceY, 'wav_file', SMILEbalanceY, 'audio_file')
    # Flow.connect(WAVbalanceZ, 'wav_file', SMILEbalanceZ, 'audio_file')
    # Flow.connect(getBalance, 'row', SMILEbalanceX, 'row')
    # Flow.connect(getBalance, 'row', SMILEbalanceY, 'row')
    # Flow.connect(getBalance, 'row', SMILEbalanceZ, 'row')
    # SMILEbalanceX.inputs.table_stem = \
    #     os.path.join(feature_table_path, 'balance_x{0}'.format(smile_string))
    # SMILEbalanceY.inputs.table_stem = \
    #     os.path.join(feature_table_path, 'balance_y{0}'.format(smile_string))
    # SMILEbalanceZ.inputs.table_stem = \
    #     os.path.join(feature_table_path, 'balance_z{0}'.format(smile_string))

    # ------------------------------------------------------------------------
    # Repeat for walk data:
    # ------------------------------------------------------------------------
    # SMILEwalkX = Node(name='openSMILE_walk_x',
    #                   interface=Fn(function=run_openSMILE,
    #                                input_names=['audio_file',
    #                                             'command',
    #                                             'flag1',
    #                                             'flags',
    #                                             'flagn',
    #                                             'args',
    #                                             'closing',
    #                                             'row',
    #                                             'table_stem',
    #                                             'save_rows'],
    #                                output_names=['feature_row',
    #                                              'feature_table']))
    # SMILEwalkX.inputs.command = 'SMILExtract'
    # SMILEwalkX.inputs.flag1 = '-I'
    # SMILEwalkX.inputs.flags = '-C'
    # SMILEwalkX.inputs.flagn = '-csvoutput'
    # SMILEwalkX.inputs.args = smile_config_file
    # SMILEwalkX.inputs.closing = '-nologfile 1'
    # SMILEwalkX.inputs.save_rows = True

    # #SMILEwalkX = SMILEbalanceX.clone('openSMILE_walk_x')
    # SMILEwalkY = SMILEwalkX.clone('openSMILE_walk_y')
    # SMILEwalkZ = SMILEwalkX.clone('openSMILE_walk_z')
    # Flow.connect(WAVwalkX, 'wav_file', SMILEwalkX, 'audio_file')
    # Flow.connect(WAVwalkY, 'wav_file', SMILEwalkY, 'audio_file')
    # Flow.connect(WAVwalkZ, 'wav_file', SMILEwalkZ, 'audio_file')
    # Flow.connect(getWalking, 'row', SMILEwalkX, 'row')
    # Flow.connect(getWalking, 'row', SMILEwalkY, 'row')
    # Flow.connect(getWalking, 'row', SMILEwalkZ, 'row')
    # SMILEwalkX.inputs.table_stem = \
    #     os.path.join(feature_table_path, 'walk_x{0}'.format(smile_string))
    # SMILEwalkY.inputs.table_stem = \
    #     os.path.join(feature_table_path, 'walk_y{0}'.format(smile_string))
    # SMILEwalkZ.inputs.table_stem = \
    #     os.path.join(feature_table_path, 'walk_z{0}'.format(smile_string))

# ============================================================================
#
# Tapping (touchscreen)
#
# ============================================================================
if synID_tap and setup_rows:
    if not os.path.isdir(path_tap):
        os.makedirs(path_tap)

    # ------------------------------------------------------------------------
    # Retrieve information about all tap files in Synapse table:
    # ------------------------------------------------------------------------
    GetTappingRows = GetPhonationRows.clone('retrieve_tap_rows')
    GetTappingRows.inputs.synapse_table = synID_tap
    GetTappingRows.inputs.save_path = path_tap
    Flow.add_nodes([GetTappingRows])

elif synID_tap and not setup_rows:
    if records:
        fid = open(records)
        lines = fid.readlines()
        rows_tap = []
        for recordId in lines:
            [rows_tap.append(os.path.join(path_tap, f))
             for f in os.listdir(path_tap) if recordId.strip() in f]
    else:
        rows_tap = [os.path.join(path_tap, f)
                    for i, f in enumerate(sorted(os.listdir(path_tap)))
                    if i < args.rows
                    and os.path.isfile(os.path.join(path_tap, f))]

    # ------------------------------------------------------------------------
    # Tap data: retrieve each row + json file from Synapse table:
    # ------------------------------------------------------------------------
    getTap = Node(name='tap_data',
                  interface=Fn(function=get_tap,
                               input_names=['synapse_table',
                                            'row',
                                            'column_name',
                                            'start',
                                            'out_path',
                                            'username',
                                            'password'],
                               output_names=['tx',
                                             'ty',
                                             't',
                                             'sample_rate',
                                             'duration',
                                             'row',
                                             'file_path']))
    getTap.inputs.synapse_table = synID_tap
    getTap.iterables = ("row", rows_tap)
    getTap.inputs.column_name = 'tapping_results.json.TappingSamples'
    getTap.inputs.start = 0
    getTap.inputs.out_path = None
    getTap.inputs.username = ''
    getTap.inputs.password = ''

    # ------------------------------------------------------------------------
    # tap_features() on balance data (each axis):
    # ------------------------------------------------------------------------
    Tap = Node(name='tap_features',
               interface=Fn(function=run_tap_features,
                            input_names=['xtaps',
                                         'ytaps',
                                         't',
                                         'threshold',
                                         'row',
                                         'file_path',
                                         'table_stem',
                                         'save_rows'],
                            output_names=['feature_row',
                                          'feature_table']))
    Flow.connect(getTap, 'tx', Tap, 'xtaps')
    Flow.connect(getTap, 'ty', Tap, 'ytaps')
    Flow.connect(getTap, 't', Tap, 't')
    Tap.inputs.threshold = 20
    Flow.connect(getTap, 'row', Tap, 'row')
    Flow.connect(getTap, 'file_path', Tap, 'file_path')
    Tap.inputs.table_stem = os.path.join(feature_table_path, 'tap')
    Tap.inputs.save_rows = True

    # ------------------------------------------------------------------------
    # Symbolic Dynamic Filtering on walk data (each axis):
    # ------------------------------------------------------------------------
    sdfTap = Node(name='sdf_tap_features',
                  interface=Fn(function=run_sdf_features,
                               input_names=['data',
                                            'number_of_symbols',
                                            'row',
                                            'file_path',
                                            'table_stem',
                                            'save_rows'],
                               output_names=['feature_row',
                                             'feature_table']))
    sdfTap.inputs.number_of_symbols = 4
    Flow.connect(getTap, 'tx', sdfTap, 'data')
    Flow.connect(getTap, 'row', sdfTap, 'row')
    Flow.connect(getTap, 'file_path', sdfTap, 'file_path')
    sdfTap.inputs.table_stem = os.path.join(feature_table_path, 'tap_sdf')
    sdfTap.inputs.save_rows = True


# ============================================================================
#
# Run workflows
#
# ============================================================================
if __name__ == '__main__':

    from time import time
    time0 = time()

    # ------------------------------------------------------------------------
    # Workflow configuration: provenance tracking, content hashing, etc.:
    # ------------------------------------------------------------------------
    # config.enable_provenance()
    Flow.config['execution']['hash_method'] = 'timestamp'
    Flow.config['execution']['local_hash_check'] = False
    Flow.config['execution']['create_report'] = args.reports

    # ------------------------------------------------------------------------
    # Generate a visual graph:
    # ------------------------------------------------------------------------
    graph_vis = args.graph
    if graph_vis:
        if graph_vis == 'exec':
            Flow.write_graph(graph2use=graph_vis, simple_form=False)
        else:
            if graph_vis == 'hier':
                graph_vis = 'hierarchical'
            Flow.write_graph(graph2use=graph_vis)

    # ------------------------------------------------------------------------
    # Debug: http://nipy.org/nipype/users/config_file.html#debug-configuration
    # ------------------------------------------------------------------------
    debug = False
    if debug:
        config.set('logging', 'workflow_level', 'DEBUG')
        logging.update_logging(config)
        Flow.config['execution']['stop_on_first_rerun'] = True
        args.numproc = 1

    # ------------------------------------------------------------------------
    # Run with or without a plugin:
    # Ex: workflow.run(plugin='SGEGraph',
    #                  plugin_args = {'dont_resubmit_completed_jobs': True})
    # ------------------------------------------------------------------------
    if args.plugin:
        if args.plugin_args:
            Flow.run(plugin=args.plugin, plugin_args=eval(args.plugin_args))
        else:
            Flow.run(plugin=args.plugin)
    elif args.numproc > 1:
        Flow.run(plugin='MultiProc',
                 plugin_args={'n_procs': args.numproc})
    else:
        Flow.run()  # Use all processors: Flow.run(plugin='MultiProc')

    print('Done! ({0:0.2f} seconds)'.format(time() - time0))
